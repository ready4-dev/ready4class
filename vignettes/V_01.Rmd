---
title: "Author Classes And Methods That Extend The Ready4 Framework"
output: 
  rmarkdown::html_vignette:
    toc: true
  pdf_document:
    highlight: null
    number_sections: yes
vignette: >
  %\VignetteIndexEntry{Author Classes And Methods That Extend The Ready4 Framework}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---
```{r echo = F}
knitr::opts_chunk$set(echo = TRUE)
```
```{r results='hide', message=FALSE}
library(ready4class)
library(ready4show)
library(ready4use)
```

The [ready4 framework](https://www.ready4-dev.com/) for open and modular computational models of mental health systems is implemented using object oriented programming (OOP). That means that the framework largely consists of classes (representations of data structures useful for modelling mental health systems) and methods (algorithms that can be applied to these data-structures to generate insight useful for policy-making).

## Motivation

The motivation for using OOP approaches to model mental health systems can be summarised under headings corresponding to the four most commonly noted features of OOP - encapsulation, inheritence, abstraction and polymorphism.

### Encapsulation
Encapsulation allows us to define the data structures (“classes”) used in modelling projects in a manner that allows them to be safely combined. Modular approaches to model development in turn allow us to progressively build up more complex representations of mental health systems through the linking of multiple models that each describe distinctive features of mental health systems. For example, encapsulated code allows all of the features and functionality of Model A to be made available to Model B, while simultaneously protecting the integrity of Model A. Model B can only interact with Model A using the algorithms (“methods”) already defined for Model A. If appropriately implemented, methods will work with any combination of input values that can be encapsulated by a class - making models more generalisable.

### Inheritence
In many cases, most but not all of a method may be generalisable to similar modelling projects. For example, much of the code from a model of the Australian mental health system may be reusable in a model exploring similar topics within the UK context, but some steps may need to be modified for features that diverge between the two jurisdictions. Inheritance enables a “child” class (e.g. one relevant to a UK implementation) to be created from a “parent” class (e.g. Australian original). By default, the “child” inherits all of the features of the “parent” including all methods associated with the “parent” class. Importantly however, alternative or additional features can also be specified for the “child” to allow it to implement different methods where necessary.

### Polymorphism
The same top-level set of commands (e.g. a call to the method “investigate” or a sequence of such commands) can be applied to both a class used for modelling the Australian mental health system and a class used for modelling the UK system, but implementation of these commands can vary based on the class that each method is applied to. This “polymorphism” allows for similar concepts to be represented using consistent syntax and for the same top level code to be generalised to multiple model implementations. Algorithms are therefore simpler to understand and easier to re-use.

### Abstraction
The simplicity enabled by polymorphism is enhanced by Abstraction, which basically means that only the briefest and easiest to comprehend parts of the code are exposed by default to potential users. Once an instance of a class is created, the entire program to ingest model data, analyse it and produce a scientific summary can be represented in a few brief lines of code, readily comprehensible to non-coders. When using open source languages, the elegance and simplicity of abstraction [does not restrict the ability of more technically minded users exploring the detailed workings of the underpinning code](https://ready4-dev.github.io/ready4fun/articles/V_01.html).

## Implementing OOP in the ready4 framework
There are numerous existing third party R packages (`devtools`, `methods` and others) that are useful for authoring and documenting classes and methods. The tools contained in these packages present developers with a great degree of flexibility in how to approach object oriented programming within R. However, the more developers exercise this flexibility, the less standardised the output.  `ready4class` has been developed to help ensure that developers extending the `ready4 framework` apply consistent naming, representation and documenting conventions when authoring classes and methods for R packages.

## Workflow

`ready4class` is an extension of the workflow tools for authoring ready4 framework R package functions that are described briefly in [this vignette from the ready4fun package](https://ready4-dev.github.io/ready4fun/articles/V_01.html). The tools included in `ready4class` are intended for use as part of [ready4pack R package authoring workflow](https://ready4-dev.github.io/ready4pack/articles/V_01.html).

The two classes exported as part of `ready4class` that are used in the `ready4pack` workflow are `ready4class_constructor` and `ready4class_pt_lup`. `ready4class_constructor` is a tibble based class in which the properties of the classes to be authored are declared. Instances of `ready4class_constructor` are most efficiently created using the `make_pt_ready4class_constructor` function. Examples of how to use `ready4class_constructor` and `ready4class_pt_lup` are referenced in the [a vignette from the ready4pack package](https://ready4-dev.github.io/ready4pack/articles/V_01.html)

`ready4class_pt_lup` is another tibble based class, which contains metadata on the prototypes of classes that can be used as sub-components of other classes (for example a tibble based class can be used as a slot in an S4 class). When authoring ready4 R packages, you will create a `ready4class_pt_lup` and store it in an online repository that you have write permissions to. As you create new classes using `ready4class` tools, your `ready4class_pt_lup` object will be updated so that these classes can be easily incorporated into any other classes you make in future. An example of an `ready4class_pt_lup` object is reproduced below.

```{r ptlup, tab.cap='Class Prototypes Lookup Table', tab.id = 'ptlup', results = "asis"}
x <- ready4use::Ready4useRepos(gh_repo_1L_chr = "ready4-dev/ready4",
                               gh_tag_1L_chr = "Documentation_0.0") %>%
  ingest(fls_to_ingest_chr = "prototype_lup",
         metadata_1L_lgl = F) 
exhibit(x)
```

## Future documentation

It should be noted that some `ready4class` methods require files of a standardised format to be saved in specific sub-directories of the package `data-raw` directory. Detailed instructions on how to prepare these files are not yet available, but will be outlined in documentation to be released in 2022.

